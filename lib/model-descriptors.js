Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = exports.type = undefined;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

var _propUtils = require('@ngyv/prop-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TYPE_OPTIONS = (0, _freeze2.default)(['required', 'default', 'acceptedTypes']);

var TYPE_NAMES = (0, _keys2.default)(_propUtils.types);

/**
 * Takes in model descriptors and returns a flat object
 * @param  {string} typeName  String representation of prop types
 * @param  {boolean} required  Indicates validation
 * @param  {(number|boolean|string|array|object)} default  Fallback value
 * @return {object}
 */
var type = function type(typeName) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!TYPE_NAMES.includes(typeName)) {
    throw new TypeError('Unexpected "' + typeName + '" passed as "typeName"');
  }

  return (0, _keys2.default)(options).reduce(function (hashType, optionKey) {
    if (TYPE_OPTIONS.includes(optionKey)) {
      hashType[optionKey] = options[optionKey];
    }
    return hashType;
  }, { type: _propUtils.types[typeName] });
};

/**
 * Validates attribute with expected type if required is true
 * @param  {*} attribute  To be validated on
 * @param  {object} [type={}]  To be validated against and is generated by `type` function
 * @return {boolean}
 */
var validate = function validate(attribute) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!type.type) {
    return;
  }

  if (!(0, _propUtils.comparePropertyToType)(attribute, type.type, type.acceptedTypes)) {
    var message = 'Expected "' + (0, _propUtils.getTypeName)(type.type) + '" but got property "' + attribute + '" of type "' + (0, _propUtils.getPropertyTypeName)(attribute) + '" instead';
    if (type.required) {
      throw new TypeError(message);
    } else {
      console.warn(message); // eslint-disable-line no-console
    }
    return false;
  }
  return true;
};

exports.type = type;
exports.validate = validate;